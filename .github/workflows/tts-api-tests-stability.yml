name: TTS API Testing 50 iterations (global<=40, per-API status WARN>15 FAIL>30)

on:
  push:
    branches: ["main"]

  schedule:
    # 05:17 KST (20:17 UTC, ì „ë‚ )
    - cron: "17 20 * * *"
    # 06:11 KST (21:11 UTC, ì „ë‚ )
    - cron: "11 21 * * *"
    # 17:11 KST (08:11 UTC)
    - cron: "11 8 * * *"

  workflow_dispatch:

concurrency:
  group: api-test-schedule
  cancel-in-progress: false

jobs:
  newman:
    runs-on: ubuntu-latest
    env:
      ITERATIONS: "50"
      APIS_PER_ITERATION: "12"
      ASSERTIONS_PER_API: "3"

      # Global gate: total AssertionError
      GLOBAL_ASSERTION_THRESHOLD: "40"

      # Per-API status policy (portfolio-friendly):
      # - WARN: known flaky range (CI PASS, but visibility)
      # - FAIL: beyond known range (CI FAIL)
      PER_API_STATUS_WARN_THRESHOLD: "15"
      PER_API_STATUS_FAIL_THRESHOLD: "30"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          npm install newman newman-reporter-htmlextra

      - name: Run Newman (capture output)
        run: |
          mkdir -p report
          npx newman run ./collections/tts_collection.json \
            -n $ITERATIONS \
            --reporters cli,htmlextra \
            --reporter-htmlextra-export report/api-test-report.html \
            2>&1 | tee report/newman.log

      # âœ… Trigger / actor meta
      - name: Set trigger info
        if: always()
        id: trigger
        run: |
          echo "trigger_type=${{ github.event_name }}" >> $GITHUB_OUTPUT

          if [ "${{ github.event_name }}" = "schedule" ]; then
            echo "trigger_user=scheduled" >> $GITHUB_OUTPUT
          else
            echo "trigger_user=${{ github.actor }}" >> $GITHUB_OUTPUT
          fi

      # âœ… Extract failure meta + bullets (always)
      - name: Extract failure meta (from newman.log)
        if: always()
        id: meta
        run: |
          FAILURE_COUNT=$(grep -c "AssertionError" report/newman.log || true)
          TOTAL_ASSERTIONS=$(( $ITERATIONS * $APIS_PER_ITERATION * $ASSERTIONS_PER_API ))

          FAILURE_RATE=$(awk -v f="$FAILURE_COUNT" -v t="$TOTAL_ASSERTIONS" 'BEGIN { if (t==0) print "0.00"; else printf "%.2f", (f/t)*100 }')

          echo "failure_count=$FAILURE_COUNT" >> $GITHUB_OUTPUT
          echo "total_assertions=$TOTAL_ASSERTIONS" >> $GITHUB_OUTPUT
          echo "failure_rate=$FAILURE_RATE" >> $GITHUB_OUTPUT

          echo "global_threshold=$GLOBAL_ASSERTION_THRESHOLD" >> $GITHUB_OUTPUT
          echo "status_warn_threshold_per_api=$PER_API_STATUS_WARN_THRESHOLD" >> $GITHUB_OUTPUT
          echo "status_fail_threshold_per_api=$PER_API_STATUS_FAIL_THRESHOLD" >> $GITHUB_OUTPUT

          # summarize-newman-log.js outputs:
          # assertion_error_count=...
          # failure_bullets<<EOF ... EOF
          # NOTE: summaryëŠ” FAIL ê¸°ì¤€ìœ¼ë¡œ ìš°ì„  ìš”ì•½ (ìš´ì˜/í’ˆì§ˆ ê²Œì´íŠ¸ ê¸°ì¤€ ëª…í™•í™”)
          node scripts/summarize-newman-log.js report/newman.log 10 $PER_API_STATUS_FAIL_THRESHOLD >> $GITHUB_OUTPUT

      # âœ… Gate check (always) - do NOT fail job here (Slack ë¶„ê¸° ìœ„í•´)
      # check-newman-threshold.js outputs:
      # global_gate_pass, status_gate_pass, status_warn, warn_status_apis, over_status_apis, ...
      - name: Check gates (global + per-API status with WARN)
        if: always()
        id: gate
        continue-on-error: true
        run: |
          node scripts/check-newman-threshold.js \
            report/newman.log \
            $GLOBAL_ASSERTION_THRESHOLD \
            $PER_API_STATUS_FAIL_THRESHOLD \
            $PER_API_STATUS_WARN_THRESHOLD

      - name: Upload HTML report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: api-test-report-html
          path: report/api-test-report.html

      - name: Upload Newman log artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: newman-log
          path: report/newman.log

      - name: Install jq
        if: always()
        run: sudo apt-get update && sudo apt-get install -y jq

      # âœ… Build artifact links (always)
      - name: Build artifact links
        if: always()
        id: links
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          API_URL="https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts"
          JSON=$(curl -sS -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" "$API_URL")

          HTML_ID=$(echo "$JSON" | jq -r '.artifacts[] | select(.name=="api-test-report-html") | .id' | head -n 1)
          LOG_ID=$(echo "$JSON" | jq -r '.artifacts[] | select(.name=="newman-log") | .id' | head -n 1)

          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          if [ -n "$HTML_ID" ] && [ "$HTML_ID" != "null" ]; then
            HTML_URL="${RUN_URL}/artifacts/${HTML_ID}"
          else
            HTML_URL="${RUN_URL}"
          fi

          if [ -n "$LOG_ID" ] && [ "$LOG_ID" != "null" ]; then
            LOG_URL="${RUN_URL}/artifacts/${LOG_ID}"
          else
            LOG_URL="${RUN_URL}"
          fi

          echo "run_url=$RUN_URL" >> $GITHUB_OUTPUT
          echo "html_url=$HTML_URL" >> $GITHUB_OUTPUT
          echo "log_url=$LOG_URL" >> $GITHUB_OUTPUT

      # ---------------------------------------------------------
      # Slack: 5 ìœ í˜• ì™„ì „ ë¶„ë¦¬ (clean / pass / pass-with-warn / fail-per-api / fail-global)
      # ---------------------------------------------------------

      # 1) âœ… Clean (no assertion errors)
      - name: Slack notify (1. clean)
        if: always() && steps.meta.outputs.failure_count == '0'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "âœ… Newman CI PASS (clean)",
              "blocks": [
                { "type": "header", "text": { "type": "plain_text", "text": "âœ… Newman CI PASS (clean)" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Trigger*: `${{ steps.trigger.outputs.trigger_type }}`\n*Actor*: `${{ steps.trigger.outputs.trigger_user }}`" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Repo*: `${{ github.repository }}`\n*Branch*: `${{ github.ref_name }}`\n*FailureCount(AssertionError)*: *0*\n*Global Threshold*: `${{ steps.meta.outputs.global_threshold }}`\n*Per-API Status Policy*: WARN>`${{ steps.meta.outputs.status_warn_threshold_per_api }}`, FAIL>`${{ steps.meta.outputs.status_fail_threshold_per_api }}`" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Run*: ${{ steps.links.outputs.run_url }}\n*HTML Report*: ${{ steps.links.outputs.html_url }}\n*newman.log*: ${{ steps.links.outputs.log_url }}" } }
              ]
            }

      # 2) âœ… PASS (assertion errors exist, no WARN, gates passed)
      - name: Slack notify (2. pass - no warn)
        if: |
          always() &&
          steps.meta.outputs.failure_count != '0' &&
          steps.gate.outputs.global_gate_pass == 'true' &&
          steps.gate.outputs.status_gate_pass == 'true' &&
          steps.gate.outputs.status_warn != 'true'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "âœ… Newman CI PASS (assertion errors, within gates)",
              "blocks": [
                { "type": "header", "text": { "type": "plain_text", "text": "âœ… Newman CI PASS (assertion errors, within gates)" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Trigger*: `${{ steps.trigger.outputs.trigger_type }}`\n*Actor*: `${{ steps.trigger.outputs.trigger_user }}`" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Repo*: `${{ github.repository }}`\n*Branch*: `${{ github.ref_name }}`\n*FailureCount(AssertionError)*: *${{ steps.meta.outputs.failure_count }}* / Global Threshold: `${{ steps.meta.outputs.global_threshold }}`\n*Assertion Failure Rate*: *${{ steps.meta.outputs.failure_rate }}%* (`${{ steps.meta.outputs.failure_count }}` / `${{ steps.meta.outputs.total_assertions }}`)\n*Per-API Status Policy*: WARN>`${{ steps.meta.outputs.status_warn_threshold_per_api }}`, FAIL>`${{ steps.meta.outputs.status_fail_threshold_per_api }}`\n*Gate result*: PASS (global + per-API status)" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Failed APIs / Assertions (summary)*\n${{ steps.meta.outputs.failure_bullets }}" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Run*: ${{ steps.links.outputs.run_url }}\n*HTML Report*: ${{ steps.links.outputs.html_url }}\n*newman.log*: ${{ steps.links.outputs.log_url }}" } }
              ]
            }

      # 3) âš ï¸ PASS with WARN (gates passed, but WARN present)
      - name: Slack notify (3. pass - with warn)
        if: |
          always() &&
          steps.meta.outputs.failure_count != '0' &&
          steps.gate.outputs.global_gate_pass == 'true' &&
          steps.gate.outputs.status_gate_pass == 'true' &&
          steps.gate.outputs.status_warn == 'true'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "âš ï¸ Newman CI PASS (with WARN: known flaky range)",
              "blocks": [
                { "type": "header", "text": { "type": "plain_text", "text": "âš ï¸ Newman CI PASS (with WARN: known flaky range)" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Trigger*: `${{ steps.trigger.outputs.trigger_type }}`\n*Actor*: `${{ steps.trigger.outputs.trigger_user }}`" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Repo*: `${{ github.repository }}`\n*Branch*: `${{ github.ref_name }}`\n*FailureCount(AssertionError)*: *${{ steps.meta.outputs.failure_count }}* / Global Threshold: `${{ steps.meta.outputs.global_threshold }}`\n*Assertion Failure Rate*: *${{ steps.meta.outputs.failure_rate }}%* (`${{ steps.meta.outputs.failure_count }}` / `${{ steps.meta.outputs.total_assertions }}`)\n*Per-API Status Policy*: WARN>`${{ steps.meta.outputs.status_warn_threshold_per_api }}`, FAIL>`${{ steps.meta.outputs.status_fail_threshold_per_api }}`\n*Gate result*: PASS (global + per-API status)\n*WARN status APIs*: `${{ steps.gate.outputs.warn_status_apis }}`" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Failed APIs / Assertions (summary)*\n${{ steps.meta.outputs.failure_bullets }}" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Run*: ${{ steps.links.outputs.run_url }}\n*HTML Report*: ${{ steps.links.outputs.html_url }}\n*newman.log*: ${{ steps.links.outputs.log_url }}" } }
              ]
            }

      # 4) âŒ FAIL: global PASS but per-API status FAIL
      - name: Slack notify (4. fail - per-API status)
        if: |
          always() &&
          steps.meta.outputs.failure_count != '0' &&
          steps.gate.outputs.global_gate_pass == 'true' &&
          steps.gate.outputs.status_gate_pass == 'false'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "âŒ Newman CI FAILED (per-API status gate breached)",
              "blocks": [
                { "type": "header", "text": { "type": "plain_text", "text": "âŒ Newman CI FAILED (per-API status gate breached)" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Trigger*: `${{ steps.trigger.outputs.trigger_type }}`\n*Actor*: `${{ steps.trigger.outputs.trigger_user }}`" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Repo*: `${{ github.repository }}`\n*Branch*: `${{ github.ref_name }}`\n*FailureCount(AssertionError)*: *${{ steps.meta.outputs.failure_count }}* / Global Threshold: `${{ steps.meta.outputs.global_threshold }}`\n*Assertion Failure Rate*: *${{ steps.meta.outputs.failure_rate }}%* (`${{ steps.meta.outputs.failure_count }}` / `${{ steps.meta.outputs.total_assertions }}`)\n*Per-API Status Policy*: WARN>`${{ steps.meta.outputs.status_warn_threshold_per_api }}`, FAIL>`${{ steps.meta.outputs.status_fail_threshold_per_api }}`\n*Gate result*: FAIL (per-API status)\n*Over status APIs*: `${{ steps.gate.outputs.over_status_apis }}`\n*WARN status APIs*: `${{ steps.gate.outputs.warn_status_apis }}`" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Failed APIs / Assertions (summary)*\n${{ steps.meta.outputs.failure_bullets }}" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Run*: ${{ steps.links.outputs.run_url }}\n*HTML Report*: ${{ steps.links.outputs.html_url }}\n*newman.log*: ${{ steps.links.outputs.log_url }}" } }
              ]
            }

      # 5) ðŸš¨ FAIL: global threshold breached (regardless of per-API status)
      - name: Slack notify (5. fail - global)
        if: always() && steps.gate.outputs.global_gate_pass == 'false'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "ðŸš¨ Newman CI FAILED (global threshold breached)",
              "blocks": [
                { "type": "header", "text": { "type": "plain_text", "text": "ðŸš¨ Newman CI FAILED (global threshold breached)" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Trigger*: `${{ steps.trigger.outputs.trigger_type }}`\n*Actor*: `${{ steps.trigger.outputs.trigger_user }}`" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Repo*: `${{ github.repository }}`\n*Branch*: `${{ github.ref_name }}`\n*Global FailureCount(AssertionError)*: *${{ steps.gate.outputs.global_failure_count }}* / Global Threshold: `${{ steps.gate.outputs.global_threshold }}`\n*Assertion Failure Rate*: *${{ steps.meta.outputs.failure_rate }}%* (`${{ steps.meta.outputs.failure_count }}` / `${{ steps.meta.outputs.total_assertions }}`)\n*Per-API Status Policy*: WARN>`${{ steps.meta.outputs.status_warn_threshold_per_api }}`, FAIL>`${{ steps.meta.outputs.status_fail_threshold_per_api }}`\n*Gate result*: FAIL (global)\n*Over status APIs*: `${{ steps.gate.outputs.over_status_apis }}`\n*WARN status APIs*: `${{ steps.gate.outputs.warn_status_apis }}`" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Failed APIs / Assertions (summary)*\n${{ steps.meta.outputs.failure_bullets }}" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Run*: ${{ steps.links.outputs.run_url }}\n*HTML Report*: ${{ steps.links.outputs.html_url }}\n*newman.log*: ${{ steps.links.outputs.log_url }}" } }
              ]
            }

      # âœ… Finalize: mark job as failed ONLY if any FAIL gate failed
      - name: Finalize job status (fail if any FAIL gate failed)
        if: always()
        run: |
          if [ "${{ steps.gate.outputs.global_gate_pass }}" = "true" ] && [ "${{ steps.gate.outputs.status_gate_pass }}" = "true" ]; then
            echo "[PASS] FAIL gates passed (global + per-API status)."
            exit 0
          fi
          echo "[FAIL] FAIL gates breached. Marking job as failed."
          exit 1
